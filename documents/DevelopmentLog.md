# 开发日志

- [2024-9-6 23:44:45] : 新增进制转化类
- [2024-9-6 20:30:39] : 新增`Transfer-Encoding`分块编码响应的API宏
- [2024-9-6 20:08:19] : 可以粗略的估计, 确实有性能提升 | 但是不知道为什么提示`timeout`, 明明浏览器也可以正常访问のくせに (发现为什么`timeout`了, 你只要设置为`--timeout 5s`就不会啦)
```sh
# 测试环境: [WSL: Arch Linux]
# 文件读写: `static/test/github.html` 大小约: 366 KB

# 分片编码(`transfer-encoding`), 每次只读取最多`4096`字节, 就直接发送
╰─ wrk -c900 -d300s https://localhost:28205/files/awa
Running 5m test @ https://localhost:28205/files/awa
  2 threads and 900 connections
  Thread Stats   Avg      Stdev     Max   +/- Stdev
    Latency   637.13ms  267.39ms   2.00s    74.85%
    Req/Sec     1.35k   181.32     2.23k    71.08%
  803134 requests in 5.00m, 140.47GB read
  Socket errors: connect 0, read 0, write 0, timeout 942
Requests/sec:   2676.27   # 可以发现, 并发量翻倍
Transfer/sec:    479.32MB # 每秒读取速率差不多 (可以估计算是硬件速度上限?)

# 单文件全部读取, 再发送 (使用`Content-Length`)
╰─ wrk -c900 -d300s https://localhost:28205/test
Running 5m test @ https://localhost:28205/test
  2 threads and 900 connections
^C  Thread Stats   Avg      Stdev     Max   +/- Stdev
    Latency   661.61ms  298.27ms   2.00s    76.56%
    Req/Sec   668.50    131.92     0.94k    84.11%
  28499 requests in 22.03s, 10.08GB read
  Socket errors: connect 0, read 0, write 0, timeout 331
Requests/sec:   1293.60
Transfer/sec:    468.65MB
```

- [2024-9-6 18:16:09] : 服务端支持分片编码(`transfer-encoding`)以发送大文件
- [2024-9-6 09:34:20] : 重构服务端请求解析, 现在可以解析带有`transfer-encoding`的客户端请求~
- [2024-9-5 15:25:57] : 修改`StringUtil::split`使用C++风格分割, 而不是: C语言风格并且在栈上分配
- [2024-9-5 15:17:39] : 重构客户端读取, 现在完全支持`分块编码`
- [2024-9-5 09:26:23] : 不仅如此, 甚至单独的请求头的一段都可以被分块发送, 并且一`\r\n`结尾...艹
- [2024-9-4 14:09:29] : 发现, 服务端响应几乎是[https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Transfer-Encoding]这种, 分块编码..
- [2024-9-4 10:47:16] : 成功实现客户端的https请求(支持代理), 但是如果请求头是分片发送的, 则可能会解析失败(bug!)
- [2024-9-3 17:29:53] : 修改客户端/websocket全部为自实现的红黑树计时器+`whenAny`作为超时计时器
- [2024-9-3 17:05:50] : 采用自主实现的红黑树计时器替代io_uring的计时器 (还有websocket没有适配) | 发现问题: `whenAny`如果第一个参数不是计时器, 而是自定义的协程, 有可能会段错误qwq..
- [2024-9-3 14:50:57] : 优化Acceptor部分代码
- [2024-9-2 20:29:25] : 似乎是我无法解决的, 与其修bug, 不如重构, 我们自己实现计时器, 不用io_uring的计时器了!, 反正如果日后支持IOCP的话也是需要自己实现的!!!!
- [2024-9-2 17:41:34] : 修复了之前的bug, 现在新增2个bug, 还有前几天的bug也旧病复发了(或者说潜伏期结束了..)
- [2024-9-2 08:58:34] : 依旧是去掉计时器就完全没有问题, 太奇怪了~, 给需要的计时器协程任务变量变为static也不行...
- [2024-9-1 23:13:23] : 完善Https的封装! 基本全部完成, 但是出现问题: `src/HXWeb/server/IO.cpp`的 111 行, 又出现之前的玄学bug...`it.resume();`为野指针!(一时半会排查不得..)
- [2024-8-31 22:48:24] : 初步实验io_uring+openssl进行异步解析https请求, 成功! 着手架构如何区分http和https以及是否需要提供配置http自动(强制)升级为https
- [2024-8-30 14:00:02] : 支持`socks5`代理
- [2024-8-29 23:26:20] : 初步架构客户端代理的代码框架
- [2024-8-29 16:46:18] : 完成对客户端类的编写 (新增`request`方法, 对客户端`单请求`封装, 如果需要长连接, 则可以使用原始的旧api)
- [2024-8-29 13:02:07] : 修复`TimerTask`内存泄漏问题
- [2024-8-28 20:25:28] : 重构了客户端类, 以及客户端IO, 适配响应/请求类添加对于客户端的api, 发现`TimerTask`存在内存泄漏问题!, 正在修复..
- [2024-8-27 22:02:17] : 初步实现`Socks5`协议的客户端解析的可行性代码; 重构了`IO`类, 使得职责分离
- [2024-8-27 14:31:49] : 修复在高并发时候存在协程的局部变量被释放的问题
- [2024-8-26 23:02:02] : 添加了调试! 发现问题: (似乎定位到了! 就是135行! 如果改为不定时就不会触发了(似乎))
- [2024-8-25 22:59:08] : 可能需要解决的关键问题: `it.resume();`为野指针! 不知何处注册得...
- [2024-8-25 16:43:33] : 排查了一个下午, 依旧解决不了... 艹!(rnm tq! 越来越玄学了, 先是 `it.resume();` 为野指针?!, 再是`Function not implemented`异常, 以及`corrupted double-linked list`; wdf, 能力不足了!)
- [2024-8-24 23:11:51] : 修复了一个uring阻塞等待没有效果的bug | 仍然在排查问题... 因为似乎所有的协程都有可能段错误qwq...(怎么可能被提前释放了? 明明单线程没有的问题!)
- [2024-8-23 23:08:20] : 发现一个多线程高并发时候会触发的bug, 原因不明! (位于`src/HXSTL/coroutine/loop/IoUringLoop.cpp`的`58行`, 原因是协程指针失效了?访问了野指针; 仍在排查qwq)
- [2024-8-22 23:14:13] : 修改为多线程版本(每个线程独享一个`uring`, 并且仍然是协程的!) | 可能有bug, 还不能复现, 原因不明
- [2024-8-22 21:59:34] : 新增可自定义路由失败时候的端点函数
- [2024-8-22 11:59:48] : 完成对端点函数以及api宏的重构
- [2024-8-22 11:37:50] : 完成对websocket的重构
- [2024-8-21 23:35:04] : 正在重构请求类和响应类, 目前还有websocket和端点函数以及api宏没有修改, 其他已经适配 | 采用一种基于协程事件循环`close fd`于析构函数的方法, 避免了无法在析构函数中使用协程这个问题
- [2024-8-20 22:34:25] : 支持`co_await Task`协程抛出异常, 并且可以被捕获!
- [2024-8-19 22:37:29] : 修复WebSocket的bug (1. 不应该使用whenAny来取消uring, 因为还在监听; 2. 写错变量名, debug半天...)
- [2024-8-19 17:25:09] : 初步完成WebSocket, 正在测试... (可以连接, 但是发现无法接收到消息?!)
- [2024-8-18 23:25:46] : 导入`hashlib`项目且配置CMake, 初步设计WebSocket连接解析(未完成), 修改`Response`支持直接异步写回(提供`send`函数)
- [2024-8-18 21:48:26] : 导入`OpenSSL`项目且配置CMake, 并且新增`certs/GenerateCerts.sh`以生成证书和私钥
- [2024-8-17 18:58:31] : 尝试开发 协程返回值 (`Expected<T>`(具体描述见分支`v5.0`)) 未遂

---

> [!TIP]
> 请忽略下面... | 我将以新的格式重新书写 (2024-8-17 15:46:47起)

### 协程epoll服务端BUG汇总
1. [x] 读取数据的时候, 有时候无法读取到正确的数据 (某些值被换成了`\0`)
    - 解决方案: 使用`std::span<char>`和`std::vector<char>`配合, 而不是自制`buf`类, 它他妈居然又读取到?!?
2. [x] 无法正确的断开连接: 明明客户端已经关闭, 而服务端却没有反应 | 实际上`::Accept`已经重新复用那个已经关闭的套接字, 但是`co_await`读取, 它没有反应, 一直卡在那里!
    - 解决方案: `include/HXWeb/server/ConnectionHandler.h`实际上`make`创建的是智能指针, 而我们只是需要其协程, 故不需要其对象的成员, 导致`AsyncFile`无法因协程退出而析构
3. [x] 玄学的`include/HXSTL/coroutine/loop/EpollLoop.h`的`await_suspend`的`fd == -1`的问题, 可能和2有关?!?!
    - 离奇的修复啦?!
---
4. 在`AsyncFile::asyncRead`加入了`try`以处理`[ERROR]: 连接被对方重置`, 是否有非`try`的解决方案?!

5. 依旧不能很好的实现html基于轮询的聊天室, 我都怀疑是html+js的问题了...(明明和基于回调的事件循环差不多, 都是这个问题..)
    - 发现啦: http的请求体是不带`\0`作为终止的, 因此解析的时候使用C语言风格的字符串就导致解析失败(越界了)